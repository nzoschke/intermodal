#!/usr/bin/env ruby

require "intermodal"

require "docker"
require "json"
require "net/https"
require "pathname"
require "yaml"

ENV["LANG"] = "UTF-8"

cmd     = ARGV[0]
path    = Pathname.new(ARGV[1]).realpath
app     = ARGV[2]
token   = ENV["HEROKU_AUTH_TOKEN"] || `heroku auth:token`.strip
project = path.basename.sub(/[^a-zA-Z0-9]/, "")

cmds = %w(detect build test verify release)

def abort(msg)
  puts msg
  exit 1
end

abort "usage: intermodal #{cmds.join('|')} PATH" unless ARGV.length == 3 && cmds.include?(cmd)
abort "error: PATH does not exist"               unless Dir.exists?  path
abort "error: fig.yml does not exist"            unless File.exists? path.join("fig.yml")
abort "error: DOCKER_HOST is not set"            unless ENV["DOCKER_HOST"]
abort "error: heroku auth token does not exist"  unless token

if cmd == "release"
  # assume `build` happened and the container is known
  # TODO: do this in net/https instead of docker / excon gems?
  containers = Docker::Util.parse_json Docker.connection.get("/containers/json", { all: true })
  container  = containers.detect { |c| c["Image"].start_with? project.to_s }
  image      = Docker::Util.parse_json Docker.connection.get("/images/#{container['Image']}/json")
  history    = Docker::Util.parse_json Docker.connection.get("/images/#{container['Image']}/history")

  # extract process_types from Procfile
  process_types = File.read(path.join("Procfile")).split("\n").map do |line|
    if line =~ /^([A-Za-z0-9_]+):\s*(.+)$/
      [$1, $2]
    end
  end.compact

  puts "PUT slug and process_types from Procfile to Heroku"

  uri = URI.parse("https://api.heroku.com/apps/#{app}/slugs")
  http = Net::HTTP.new(uri.host, uri.port)
  http.use_ssl = true
  request = Net::HTTP::Post.new(uri.request_uri)
  request.add_field("Content-Type",   "application/json")
  request.add_field("Accept",         "application/vnd.heroku+json; version=3")
  request.add_field("Authorization",  "Bearer #{token}")
  request.body = { process_types: Hash[process_types] }.to_json
  response = http.request(request)
  abort "error: #{response.body}" unless response.code == "201"

  slug_json = JSON.parse(response.body)
  put_url = slug_json["blob"]["url"]

  puts "Extract slug archive from container"

  pid = `docker  run  -d #{image['Id']} tar cfvz /tmp/slug.tgz -C / --exclude=.git ./app`.strip
  system "docker logs -f #{pid}"
  system "docker cp #{pid}:/tmp/slug.tgz /tmp"

  puts "PUT slug archive to S3"

  # TODO: https://github.com/rlmcpherson/s3gof3r ?
  system "curl -X PUT -H 'Content-Type:' --data-binary @/tmp/slug.tgz '#{put_url}'"
  abort "error: PUT failed" unless $? == 0

  puts "PUT release to Heroku"

  uri = URI.parse("https://api.heroku.com/apps/#{app}/releases")
  http = Net::HTTP.new(uri.host, uri.port)
  http.use_ssl = true
  request = Net::HTTP::Post.new(uri.request_uri)
  request.add_field("Content-Type",   "application/json")
  request.add_field("Accept",         "application/vnd.heroku+json; version=3")
  request.add_field("Authorization",  "Bearer #{token}")
  request.body = { slug: slug_json["id"] }.to_json
  response = http.request(request)
  abort "error: #{response.body}" unless response.code == "201"

  puts "Extract ENV from image and PATCH config vars on Heroku"

  envs = Hash[history.map { |h| h["CreatedBy"].scan(/sh .* ENV\s+([^=]+)=([^ ]+)/)[0] }.compact]

  uri = URI.parse("https://api.heroku.com/apps/#{app}/config-vars")
  http = Net::HTTP.new(uri.host, uri.port)
  http.use_ssl = true
  request = Net::HTTP::Patch.new(uri.request_uri)
  request.add_field("Content-Type",   "application/json")
  request.add_field("Accept",         "application/vnd.heroku+json; version=3")
  request.add_field("Authorization",  "Bearer #{token}")
  request.body = envs.to_json
  response = http.request(request)
  abort "error: #{response.body}" unless response.code == "200"

  puts "Detect Postgres and/or Redis from fig.yml and GET and POST on Heroku"

  uri = URI.parse("https://api.heroku.com/apps/#{app}/addons")
  http = Net::HTTP.new(uri.host, uri.port)
  http.use_ssl = true
  request = Net::HTTP::Get.new(uri.request_uri, { "accept-encoding" => "UTF-8" })
  request.add_field("Accept",         "application/vnd.heroku+json; version=3")
  request.add_field("Authorization",  "Bearer #{token}")
  response = http.request(request)
  abort "error: #{response.body}" unless response.code == "200"

  addons = JSON.parse(response.body)

  fig_yml = YAML.load_file path.join("fig.yml")

  if fig_yml["postgres"]
    if addons.detect { |a| a["name"] =~ /heroku-postgresql/ }
      puts "GET addons heroku-postgresql already exists"
    else
      uri = URI.parse("https://api.heroku.com/apps/#{app}/addons")
      http = Net::HTTP.new(uri.host, uri.port)
      http.use_ssl = true
      request = Net::HTTP::Post.new(uri.request_uri)
      request.add_field("Content-Type",   "application/json")
      request.add_field("Accept",         "application/vnd.heroku+json; version=3")
      request.add_field("Authorization",  "Bearer #{token}")
      request.body = { plan: "heroku-postgresql:dev" }.to_json
      response = http.request(request)
      abort "error: #{response.body}" unless response.code == "201"
      puts "POST addons heroku-postgresql:dev"
    end
  end

  if fig_yml["redis"]
    if addons.detect { |a| a["name"] =~ /heroku-redis/ }
      puts "GET addons heroku-redis:standard-4 already exists"
    else
      uri = URI.parse("https://api.heroku.com/apps/#{app}/addons")
      http = Net::HTTP.new(uri.host, uri.port)
      http.use_ssl = true
      request = Net::HTTP::Post.new(uri.request_uri)
      request.add_field("Content-Type",   "application/json")
      request.add_field("Accept",         "application/vnd.heroku+json; version=3")
      request.add_field("Authorization",  "Bearer #{token}")
      request.body = { plan: "heroku-redis:standard-4" }.to_json
      response = http.request(request)
      abort "error: #{response.body}" unless response.code == "201"
      puts "POST addons heroku-redis:standard-4"
    end
  end
end
